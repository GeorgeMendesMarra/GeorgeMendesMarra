---

# **Histórico do Software e da Engenharia de Software (Versão Expandida)**

## **1. Antes do software: bases teóricas (década de 1930–1940)**

Mesmo antes de existirem computadores eletrônicos modernos, já havia fundamentos conceituais que permitiriam o surgimento do software:

* **Alan Turing (1936)**: formalizou a ideia de algoritmo e de máquina universal, conceito que influenciaria toda a lógica computacional.
* **Alonzo Church** e o **Lambda Cálculo**: formalizaram funções computáveis.
* **Máquinas eletromecânicas** (Zuse Z3, 1941): demonstraram a possibilidade de programabilidade automática.

Esses trabalhos forneceram a **base matemática** para o que se tornaria o software.

---

## **2. Primeira geração de software (1940–1955): Programação de Baixo Nível**

Com computadores como ENIAC, Colossus e UNIVAC:

* Programas eram escritos diretamente em **linguagem de máquina**.
* A programação ocorria por meio de **painéis, cabos, interruptores**, sem arquivos de código como hoje.
* Grande parte da programação era feita por matemáticos e operadores de laboratório.

Características do período:

* Software era visto como **parte do hardware**, sem distinção clara.
* Não existia a profissão “programador” como hoje.

---

## **3. Segunda geração (1955–1965): A ascensão das linguagens de alto nível**

Surgem as primeiras linguagens de alto nível:

* **Fortran (1957)** – criou o paradigma de programação científica.
* **COBOL (1959)** – voltado a negócios e processamento de dados comerciais.
* **Lisp (1958)** – primeira linguagem funcional, marco para IA.

Impactos:

* Programar ficou mais acessível.
* Software passou a ser um artefato separável do hardware.
* A produtividade aumentou enormemente.

---

## **4. A Crise do Software (1960–1975): O ponto de virada**

O crescimento da complexidade dos sistemas excedeu a capacidade das técnicas da época:

* Projetos frequentemente:

  * atrasavam,
  * extrapolavam orçamento,
  * apresentavam muitos erros,
  * eram impossíveis de manter.

A expressão **“crise do software”** teve grande destaque na **Conferência NATO de 1968**, onde:

* definiu-se a necessidade de **métodos sistemáticos**,
* surgiram as primeiras discussões formais sobre **engenharia de software**.

Problemas típicos da época:

* Falta de documentação.
* Falta de padronização.
* Equipamentos caros e escassos.
* Equipes despreparadas.
* Falhas catastróficas, como:

  * explosões de foguetes,
  * sistemas bancários travando,
  * falhas de sistemas militares.

---

## **5. Anos 70–80: Engenharia de Software “Clássica”**

### Avanços importantes:

1. **Modelo Waterfall** (Royce, 1970)

   * Ciclo linear: requisitos → análise → projeto → implementação → testes → manutenção.
   * Influenciou décadas de ensino e prática.

2. **Análise estruturada**

   * Diagramas (DFD, ER, fluxogramas),
   * Modularização,
   * Maior preocupação em dividir um sistema em partes compreensíveis.

3. **Primeiras ferramentas CASE**

   * Auxiliavam diagramas, geração de código e documentação.

4. **Programação estruturada** (Dijkstra):

   * Substituiu GOTO por estruturas de controle claras.
   * Impacto direto na qualidade e legibilidade do código.

5. **Normas de qualidade**:

   * **ISO 9000**, **CMMI**, **IEEE**, entre outras.

---

## **6. A revolução das interfaces gráficas e OOP (anos 80–90)**

### Programação orientada a objetos

* Smalltalk, C++ e posteriormente Java (1995).
* Conceitos como **classe, objeto, herança e polimorfismo** tornaram projetos mais modulares.

### GUI e ambientes visuais

* Macintosh (1984) e Windows popularizaram interfaces gráficas.
* Ferramentas como Delphi e Visual Basic facilitaram desenvolvimento rápido.

### Padrões de projeto

* Catálogo *Design Patterns* (Gang of Four, 1994).
* Base conceitual para arquiteturas robustas.

---

## **7. A Web e a globalização do software (anos 90–2000)**

A internet redefiniu a engenharia de software:

* Sistemas passaram a ser **distribuídos**.
* Tiveram que lidar com:

  * escalabilidade,
  * segurança,
  * conectividade global,
  * servidores web,
  * bancos de dados robustos.

Surgiram novas áreas:

* Engenharia de requisitos moderna,
* Engenharia de usabilidade,
* Engenharia de segurança,
* Arquiteturas em camadas,
* E-commerce e sistemas críticos 24/7.

---

## **8. Métodos Ágeis (2001–2010): Uma nova cultura**

Publicado em 2001, o **Manifesto Ágil** revoluciona o setor ao propor:

* Iterações rápidas,
* Feedback constante do cliente,
* Menos burocracia,
* Entregas incrementais.

Metodologias:

* Scrum,
* XP,
* Kanban,
* Crystal,
* FDD.

Práticas-chave:

* TDD,
* Pair Programming,
* Continuous Integration.

Impacto:

* Redução da distância entre cliente e equipe.
* Maior capacidade de adaptação a mudanças.

---

## **9. DevOps, Nuvem e Automação Total (2010–2020)**

A indústria passou a exigir:

* **Entrega contínua**,
* Infraestrutura como código (IaC),
* Monitoramento e observabilidade,
* Deploys rápidos e reversíveis.

Principais tecnologias:

* Docker,
* Kubernetes,
* AWS, GCP, Azure,
* GitLab CI, Jenkins, GitHub Actions.

Mudanças:

* Desenvolvimento e operações unificaram-se,
  resultando no papel **DevOps** e depois **DevSecOps**.

---

## **10. Era atual (2020–presente): IA, MLOps e sistemas autônomos**

Tendências recentes:

* Integração de **IA e Machine Learning** em praticamente todos os sistemas.
* MLOps como disciplina complementar.
* Uso crescente de:

  * microservices,
  * arquiteturas orientadas a eventos,
  * serverless computing,
  * APIs inteligentes,
  * sistemas baseados em dados.

Desafios modernos:

* Segurança da cadeia de suprimentos (supply chain).
* Sustentabilidade (energia, nuvem, eficiência).
* Sistemas socio-técnicos complexos.
* Regulamentações (LGPD, GDPR).

---

# **Conclusão**

O software evoluiu de simples instruções manuais em hardware para sistemas inteligentes altamente distribuídos.
A Engenharia de Software, por sua vez, acompanhou esse crescimento, sempre buscando **métodos, ferramentas e princípios** para lidar com a crescente complexidade técnica, social e humana.

---
