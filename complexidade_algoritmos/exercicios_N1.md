# üß† Question√°rio ‚Äî Complexidade de Algoritmos

---

## üìò Vers√£o F√°cil

**Objetivo:** Avaliar a compreens√£o dos conceitos b√°sicos de complexidade de algoritmos, nota√ß√µes e exemplos simples.

1. O que significa a palavra **complexidade** quando falamos de um algoritmo?  
2. Qual √© a diferen√ßa entre **tempo de execu√ß√£o** e **uso de mem√≥ria** em um algoritmo?  
3. Para que serve a **nota√ß√£o Big O (O-grande)**?  
4. O que representa o termo **n** dentro da nota√ß√£o O(n)?  
5. Cite um exemplo de algoritmo com complexidade **O(1)**.  
6. Cite um exemplo de algoritmo com complexidade **O(n)**.  
7. Qual a complexidade de tempo do algoritmo de **Bubble Sort**?  
8. Qual a complexidade de tempo do algoritmo de **Busca Linear**?  
9. O que significa dizer que um algoritmo tem complexidade **O(log n)**?  
10. Qual a diferen√ßa entre **melhor caso** e **pior caso** de um algoritmo?  
11. Em qual tipo de problema geralmente encontramos complexidades **exponenciais (O(2‚Åø))**?  
12. O que √© **complexidade polinomial**?  
13. Qual a complexidade do **Merge Sort** no pior caso?  
14. Em um algoritmo que possui **dois loops for aninhados**, qual costuma ser sua complexidade?  
15. Por que os programadores buscam algoritmos com menor complexidade?  
16. Um algoritmo que analisa cada elemento de uma lista apenas uma vez √© O(n). Isso √© considerado eficiente?  
17. A nota√ß√£o **Œò (teta)** indica o qu√™ em rela√ß√£o ao crescimento da fun√ß√£o?  
18. Qual √© a complexidade de tempo de um algoritmo que executa **tr√™s loops aninhados** sobre *n* elementos?  
19. O que significa dizer que um algoritmo √© **in-place**?  
20. Cite um exemplo de **estrutura de dados** que pode melhorar a efici√™ncia de um algoritmo.

---

## üî¨ Vers√£o Dif√≠cil

**Objetivo:** Avaliar a aplica√ß√£o pr√°tica e an√°lise cr√≠tica de complexidades, rela√ß√µes de recorr√™ncia e otimiza√ß√£o.

1. Explique por que analisamos a complexidade de tempo **em fun√ß√£o do tamanho da entrada (n)**.  
2. D√™ um exemplo de algoritmo cuja complexidade muda dependendo da escolha da estrutura de dados.  
3. Mostre como se calcula a complexidade assint√≥tica da fun√ß√£o **f(n) = 4n¬≤ + 3n + 10**.  
4. Prove que **O(n¬≤ + n) = O(n¬≤)**.  
5. Qual √© a diferen√ßa entre as nota√ß√µes **O(n)** e **Œ©(n)** em termos de limites de crescimento?  
6. Escreva a rela√ß√£o de recorr√™ncia do algoritmo **Merge Sort** e resolva-a usando o **Teorema Mestre**.  
7. Mostre um exemplo de algoritmo cuja complexidade √© **O(n log n)** e explique por que esse comportamento ocorre.  
8. Explique o que significa o **custo amortizado** em opera√ß√µes de uma **tabela hash**.  
9. Dado um algoritmo com complexidade **T(n) = 2T(n/2) + n**, determine sua ordem de crescimento.  
10. Compare o desempenho de algoritmos com complexidade **O(n log n)** e **O(n¬≤)** para valores grandes de *n*.  
11. Um algoritmo recursivo √© definido por **T(n) = T(n-1) + n**. Qual √© sua complexidade aproximada?  
12. Qual o impacto da escolha de piv√¥ na complexidade m√©dia do **Quick Sort**?  
13. Explique o conceito de **limite inferior (lower bound)** para algoritmos de ordena√ß√£o.  
14. D√™ um exemplo de problema **NP-dif√≠cil** e explique o que isso significa em termos de complexidade.  
15. Por que n√£o √© poss√≠vel encontrar algoritmos polinomiais conhecidos para resolver todos os problemas **NP-completos**?  
16. Mostre um exemplo pr√°tico em que a an√°lise de complexidade **pode orientar o design de software**.  
17. Explique a diferen√ßa entre **complexidade no caso m√©dio** e **complexidade no pior caso**.  
18. Um algoritmo que compara todos os pares de elementos em uma lista de tamanho *n* possui qual complexidade?  
19. Mostre por que **f(n) = n!** cresce mais rapidamente do que **f(n) = 2‚Åø**.  
20. Se um algoritmo tem tempo de execu√ß√£o **T(n) = n¬≤ log n + 5n**, qual √© sua complexidade em nota√ß√£o O?

---

**Autor:** Prof. George Mendes Marra  
**Reposit√≥rio de refer√™ncia:** [github.com/GeorgeMendesMarra/complexidade_algoritmos](https://github.com/GeorgeMendesMarra/GeorgeMendesMarra/tree/main/complexidade_algoritmos)
